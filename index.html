<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>TracePuzzle - Single Stroke Puzzle Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Mirjan-Ali-Sha/tracepuzzle/main/TracePuzzle-icon.png">
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Mirjan-Ali-Sha/tracepuzzle/main/TracePuzzle-icon.png">
    <style>
        :root {
            --bg-color: #0d051c;
            --primary-glow: #00ffff;
            --secondary-glow: #ff00ff;
            --node-color: #ffff00;
            --text-glow-color: #00ff00;
            --text-color: #f0f0f0;
        }

        body{
            margin:0;
            padding:0;
            font-family:'Orbitron',sans-serif;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            color:var(--text-color);
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            min-height:100vh;
            overflow:hidden;
            text-align:center;
        }

        #splash-screen{
            position:fixed; top:0; left:0; width:100%; height:100%;
            background:var(--bg-color);
            z-index:2000;
            display:flex; flex-direction:column; align-items:center; justify-content:center;
            transition: opacity 1s ease-out, visibility 1s ease-out;
            opacity:1; visibility:visible;
        }
        #splash-screen.hidden{ opacity:0; visibility:hidden; }
        #splash-screen img{ width:150px; height:150px; margin-bottom:20px; animation:pulse-icon 2s infinite ease-in-out; }
        #splash-screen h1{ font-size:3rem; color:var(--primary-glow); margin:0; text-shadow: 0 0 5px var(--primary-glow); }
        #splash-screen .tagline{ font-size:1.2rem; margin-top:10px; color:var(--text-color); letter-spacing:2px; }
        #splash-screen .author{ font-size:1rem; margin-top:30px; color:rgba(255,255,255,0.7); }

        .game-container{ width:100%; max-width:500px; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; align-items:center; }
        header{ width:100%; padding:10px 0 20px 0; }
        h1{ font-size:2.5rem; margin:0; color:var(--primary-glow); animation:flicker 3s infinite alternate; }
        .stats-container{ display:flex; justify-content:space-between; align-items:center; width:100%; margin-top:10px; }
        .stats-container p{ font-size:1.2rem; margin:0; color:var(--text-glow-color); text-shadow:0 0 5px var(--text-glow-color); }

        #gameCanvas{
            background-color: rgba(0,0,0,0.2);
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0,255,255,0.3), inset 0 0 10px rgba(0,0,0,0.5);
            width:100%;
            aspect-ratio: 1/1;
            touch-action: none;
        }

        footer{ margin-top:25px; display:flex; gap:15px; justify-content:center; }

        button{
            font-family:'Orbitron',sans-serif;
            background:transparent;
            border:2px solid var(--primary-glow);
            color:var(--primary-glow);
            padding:12px 25px;
            font-size:1rem;
            border-radius:10px;
            cursor:pointer;
            transition:all 0.3s ease;
            text-shadow:0 0 5px var(--primary-glow);
            box-shadow:0 0 10px var(--primary-glow), inset 0 0 5px rgba(0,255,255,0.5);
            pointer-events: auto; /* Ensure buttons are clickable */
            z-index: 10;
        }
        button:hover, button:focus { background:var(--primary-glow); color:var(--bg-color); box-shadow:0 0 20px var(--primary-glow); }
        button:active{ transform:scale(0.95); }

        #badge-button{
            padding:5px 15px; font-size:0.9rem; border-color:var(--secondary-glow); color:var(--secondary-glow);
            text-shadow:0 0 5px var(--secondary-glow);
        }
        #badge-button:hover, #badge-button:focus { background:var(--secondary-glow); color:var(--bg-color); }

        #start-over-button { display: none; }

        .modal-overlay{
            position:fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.7); backdrop-filter: blur(5px);
            display:none; align-items:center; justify-content:center; z-index:1000;
        }
        .modal-content{
            background: var(--bg-color); padding:30px; border-radius:15px; border:2px solid var(--primary-glow);
            box-shadow:0 0 20px var(--primary-glow); text-align:center;
        }
        .modal-content h2{ margin-top:0; color:var(--primary-glow); }
        .modal-content p{ color: var(--text-color); margin-bottom: 25px; }
        .modal-buttons { display: flex; justify-content: center; gap: 15px; }
        .modal-content input{ width:100%; padding:10px; margin-top:15px; margin-bottom:20px; border-radius:8px; border:1px solid #ff00ff; background: rgba(0,0,0,0.3); color:var(--text-color); font-family:'Orbitron'; font-size:1rem; box-sizing:border-box; }

        @keyframes flicker {
            0%,18%,22%,25%,53%,57%,100%{ text-shadow: 0 0 4px #fff, 0 0 11px var(--primary-glow), 0 0 19px var(--primary-glow); }
            20%,24%,55%{ text-shadow:none; }
        }
        @keyframes pulse-icon { 0%{transform:scale(1);} 50%{transform:scale(1.05);} 100%{transform:scale(1);} }
    </style>
</head>
<body>
    <div id="splash-screen">
        <img src="https://raw.githubusercontent.com/Mirjan-Ali-Sha/tracepuzzle/main/TracePuzzle-icon.png" alt="TracePuzzle Icon">
        <h1>TracePuzzle</h1>
        <p class="tagline">One line is all you have.</p>
        <p class="author">By Mirjan Ali Sha</p>
    </div>

    <div class="game-container">
        <header>
            <h1>TracePuzzle</h1>
            <div class="stats-container">
                <p id="level-indicator">Level 1</p>
                <button id="badge-button">Get Badge</button>
                <p id="score-indicator">Score: 0</p>
            </div>
        </header>

        <canvas id="gameCanvas"></canvas>

        <footer>
            <button id="reset-button">Reset Game</button>
            <button id="start-over-button">Start Over</button>
        </footer>
    </div>

    <div id="badge-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Create Your Winner's Badge</h2>
            <input type="text" id="player-name" placeholder="Enter your name">
            <button id="save-badge-button">Save Badge</button>
        </div>
    </div>

    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>Game Over</h2>
            <p>You got stuck! Try a different path.</p>
            <div class="modal-buttons">
                <button id="play-again-button">Play Again</button>
                <button id="get-badge-from-game-over">Get Badge</button>
            </div>
        </div>
    </div>

    <script>
        // Wrap everything in try-catch for error handling
        try {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const levelIndicator = document.getElementById('level-indicator');
            const scoreIndicator = document.getElementById('score-indicator');
            const resetButton = document.getElementById('reset-button');
            const badgeButton = document.getElementById('badge-button');
            const startOverButton = document.getElementById('start-over-button');
            const badgeModal = document.getElementById('badge-modal');
            const playerNameInput = document.getElementById('player-name');
            const saveBadgeButton = document.getElementById('save-badge-button');
            const splashScreen = document.getElementById('splash-screen');
            const gameOverModal = document.getElementById('game-over-modal');
            const playAgainButton = document.getElementById('play-again-button');
            const getBadgeFromGameOverButton = document.getElementById('get-badge-from-game-over');

            console.log('All elements loaded successfully');

            const NODE_RADIUS = 12;
            const LINE_WIDTH = 6;
            const PLAYER_LINE_WIDTH = 10;
            const HIT_TOLERANCE = 25;
            const GAME_PROGRESS_KEY = 'tracePuzzleProgress';

            let scaleFactor = 1;
            let canvasPadding = 0;
            let isDragging = false;
            let currentLevelIndex = 0;
            let totalScore = 0;
            let availableLines = [];
            let tracedLines = new Set();
            let livePathEnd = null;
            let isTransitioning = false;
            let playerPath = [];
            let levelCompleted = false;

            const levels = [
                { nodes: [{ x: 20, y: 20 }, { x: 80, y: 20 }, { x: 80, y: 80 }, { x: 20, y: 80 }], lines: [[0, 1], [1, 2], [2, 3], [3, 0]], difficulty: 10 },
                { nodes: [{ x: 50, y: 20 }, { x: 20, y: 80 }, { x: 80, y: 80 }], lines: [[0, 1], [1, 2], [2, 0]], difficulty: 10 },
                { nodes: [{ x: 20, y: 20 }, { x: 80, y: 20 }, { x: 20, y: 50 }, { x: 80, y: 50 }, { x: 20, y: 80 }, { x: 80, y: 80 }], lines: [[0, 1], [1, 3], [3, 2], [2, 4], [4, 5]], difficulty: 20 },
                { nodes: [{ x: 50, y: 15 }, { x: 15, y: 40 }, { x: 85, y: 40 }, { x: 15, y: 85 }, { x: 85, y: 85 }], lines: [[0, 1], [0, 2], [1, 2], [1, 3], [2, 4], [3, 4]], difficulty: 30 },
                { nodes: [{ x: 20, y: 50 }, { x: 50, y: 20 }, { x: 80, y: 50 }, { x: 20, y: 90 }, { x: 80, y: 90 }], lines: [[0, 1], [1, 2], [2, 4], [4, 3], [3, 0], [0, 2]], difficulty: 35 },
                { nodes: [{ x: 50, y: 10 }, { x: 20, y: 50 }, { x: 80, y: 50 }, { x: 50, y: 90 }], lines: [[0, 1], [1, 2], [2, 0], [1, 3], [3, 2]], difficulty: 40 },
                { nodes: [{ x: 20, y: 20 }, { x: 50, y: 50 }, { x: 20, y: 80 }, { x: 80, y: 20 }, { x: 80, y: 80 }], lines: [[0, 1], [1, 2], [2, 0], [3, 1], [1, 4], [4, 3]], difficulty: 45 },
                { nodes: [{ x: 50, y: 10 }, { x: 20, y: 50 }, { x: 80, y: 50 }, { x: 50, y: 90 }, { x: 50, y: 50 }], lines: [[0, 1], [1, 3], [3, 2], [2, 0], [0, 4], [4, 3]], difficulty: 50 },
                { nodes: [{ x: 50, y: 10 }, { x: 85, y: 35 }, { x: 70, y: 75 }, { x: 30, y: 75 }, { x: 15, y: 35 }], lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0], [0, 2], [2, 4]], difficulty: 55 },
                { nodes: [{ x: 50, y: 10 }, { x: 80, y: 30 }, { x: 80, y: 70 }, { x: 50, y: 90 }, { x: 20, y: 70 }, { x: 20, y: 30 }], lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0], [0, 2], [2, 4], [4, 0]], difficulty: 60 },
                { nodes: [{ x: 50, y: 10 }, { x: 85, y: 35 }, { x: 70, y: 75 }, { x: 30, y: 75 }, { x: 15, y: 35 }, { x: 50, y: 45 }], lines: [[0, 2], [2, 4], [4, 1], [1, 3], [3, 0], [0, 5], [2, 5], [4, 5]], difficulty: 70 },
                { nodes: [{ x: 30, y: 25 }, { x: 70, y: 25 }, { x: 85, y: 45 }, { x: 85, y: 75 }, { x: 70, y: 90 }, { x: 30, y: 90 }, { x: 15, y: 75 }, { x: 15, y: 45 }], lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0], [0, 2], [2, 4], [4, 6], [6, 0]], difficulty: 80 },
                { nodes: [{ x: 50, y: 15 }, { x: 20, y: 50 }, { x: 50, y: 40 }, { x: 80, y: 50 }, { x: 35, y: 75 }, { x: 65, y: 75 }, { x: 50, y: 90 }], lines: [[0, 1], [1, 2], [2, 0], [0, 3], [3, 2], [1, 4], [4, 6], [6, 5], [5, 3], [2, 4]], difficulty: 85 },
                { nodes: [{ x: 50, y: 10 }, { x: 65, y: 40 }, { x: 95, y: 45 }, { x: 75, y: 65 }, { x: 80, y: 95 }, { x: 50, y: 80 }, { x: 20, y: 95 }, { x: 25, y: 65 }, { x: 5, y: 45 }, { x: 35, y: 40 }], lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 0], [1, 3], [3, 5], [5, 7], [7, 9], [9, 1]], difficulty: 90 },
                { nodes: [{ x: 25, y: 40 }, { x: 45, y: 20 }, { x: 65, y: 40 }, { x: 25, y: 75 }, { x: 65, y: 75 }, { x: 85, y: 40 }, { x: 85, y: 75 }], lines: [[0, 1], [1, 2], [2, 4], [4, 3], [3, 0], [0, 2], [2, 5], [5, 6], [6, 4], [4, 2]], difficulty: 95 },
                { nodes: [{ x: 20, y: 20 }, { x: 50, y: 20 }, { x: 80, y: 20 }, { x: 20, y: 50 }, { x: 50, y: 50 }, { x: 80, y: 50 }, { x: 20, y: 80 }, { x: 50, y: 80 }, { x: 80, y: 80 }], lines: [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8], [0, 3], [3, 6], [1, 4], [4, 7], [2, 5], [5, 8], [1, 5]], difficulty: 100 },
                { nodes: [{ x: 50, y: 10 }, { x: 80, y: 30 }, { x: 80, y: 70 }, { x: 50, y: 90 }, { x: 20, y: 70 }, { x: 20, y: 30 }], lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0], [0, 2], [2, 4], [4, 0], [1, 3], [3, 5], [5, 1]], difficulty: 110 },
                { nodes: [{ x: 50, y: 20 }, { x: 30, y: 40 }, { x: 20, y: 65 }, { x: 40, y: 85 }, { x: 60, y: 85 }, { x: 80, y: 65 }, { x: 70, y: 40 }], lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 0], [0, 3], [3, 6], [1, 4], [4, 0]], difficulty: 120 },
                { nodes: [{ x: 10, y: 70 }, { x: 50, y: 70 }, { x: 70, y: 90 }, { x: 30, y: 90 }, { x: 50, y: 30 }, { x: 30, y: 45 }, { x: 70, y: 45 }, { x: 90, y: 70 }], lines: [[0, 1], [1, 2], [2, 3], [3, 0], [1, 4], [4, 5], [5, 6], [6, 4], [1, 7], [7, 2]], difficulty: 130 },
                { nodes: [{ x: 50, y: 50 }, { x: 20, y: 20 }, { x: 50, y: 10 }, { x: 80, y: 20 }, { x: 20, y: 80 }, { x: 50, y: 90 }, { x: 80, y: 80 }], lines: [[0, 1], [1, 2], [2, 0], [0, 3], [3, 2], [0, 4], [4, 5], [5, 0], [0, 6], [6, 5]], difficulty: 150 }
            ];

            function scale(coord) { return canvasPadding + coord * scaleFactor; }

            function drawGuideLines() {
                const level = levels[currentLevelIndex];
                if (!level) return;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.18)';
                ctx.lineWidth = LINE_WIDTH;
                ctx.lineCap = 'round';
                level.lines.forEach(line => {
                    const p1 = level.nodes[line[0]];
                    const p2 = level.nodes[line[1]];
                    ctx.beginPath();
                    ctx.moveTo(scale(p1.x), scale(p1.y));
                    ctx.lineTo(scale(p2.x), scale(p2.y));
                    ctx.stroke();
                });
            }

            function drawNodes(pulse) {
                const level = levels[currentLevelIndex];
                if (!level) return;
                const nodeColor = '#ffff00';
                level.nodes.forEach((node, index) => {
                    const radius = NODE_RADIUS + 2 * Math.sin(pulse + index);
                    ctx.beginPath();
                    ctx.arc(scale(node.x), scale(node.y), radius, 0, Math.PI * 2);
                    ctx.fillStyle = nodeColor;
                    ctx.shadowColor = nodeColor;
                    ctx.shadowBlur = 20;
                    if (playerPath.length > 0 && index === playerPath[playerPath.length - 1]) {
                        ctx.shadowBlur = 35;
                    }
                    ctx.fill();
                });
                ctx.shadowBlur = 0;
            }

            function drawPlayerTrace() {
                if (!levels[currentLevelIndex] || playerPath.length < 1) return;
                const traceColor = '#ff00ff';
                ctx.strokeStyle = traceColor;
                ctx.lineWidth = PLAYER_LINE_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = traceColor;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                const firstNode = levels[currentLevelIndex].nodes[playerPath[0]];
                ctx.moveTo(scale(firstNode.x), scale(firstNode.y));
                for (let i = 1; i < playerPath.length; i++) {
                    const node = levels[currentLevelIndex].nodes[playerPath[i]];
                    ctx.lineTo(scale(node.x), scale(node.y));
                }
                ctx.stroke();
                if (isDragging && livePathEnd) {
                    const lastNode = levels[currentLevelIndex].nodes[playerPath[playerPath.length - 1]];
                    ctx.beginPath();
                    ctx.moveTo(scale(lastNode.x), scale(lastNode.y));
                    ctx.lineTo(livePathEnd.x, livePathEnd.y);
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            }

            function saveProgress() {
                try {
                    const progress = { level: currentLevelIndex, score: totalScore };
                    localStorage.setItem(GAME_PROGRESS_KEY, JSON.stringify(progress));
                } catch(e) {
                    console.error('Save error:', e);
                }
            }

            function loadProgress() {
                try {
                    const saved = localStorage.getItem(GAME_PROGRESS_KEY);
                    if (saved) {
                        const obj = JSON.parse(saved);
                        currentLevelIndex = obj.level || 0;
                        totalScore = obj.score || 0;
                    }
                } catch (e) {
                    console.error('Load error:', e);
                }
            }

            function updateUI() {
                if (currentLevelIndex >= levels.length) {
                    levelIndicator.textContent = "All Levels Done!";
                    startOverButton.style.display = 'inline-block';
                    resetButton.style.display = 'none';
                } else {
                    levelIndicator.textContent = `Level ${currentLevelIndex + 1}`;
                    startOverButton.style.display = 'none';
                    resetButton.style.display = 'block';
                }
                scoreIndicator.textContent = `Score: ${totalScore}`;
            }

            function setupLevel(levelIndex) {
                currentLevelIndex = levelIndex;
                playerPath = [];
                tracedLines.clear();
                availableLines = [];
                livePathEnd = null;
                isDragging = false;
                isTransitioning = false;
                levelCompleted = false;
                const level = levels[currentLevelIndex];
                level.lines.forEach(line => {
                    const [n1, n2] = line;
                    availableLines.push({ from: n1, to: n2 });
                    availableLines.push({ from: n2, to: n1 });
                });
                updateUI();
            }

            function resizeCanvas() {
                const containerWidth = canvas.parentElement.clientWidth;
                canvas.width = Math.round(containerWidth);
                canvas.height = Math.round(containerWidth);
                canvasPadding = canvas.width * 0.10;
                const drawableArea = canvas.width - canvasPadding * 2;
                scaleFactor = drawableArea / 100;
            }

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const isTouch = !!evt.touches;
                const clientX = isTouch ? evt.touches[0].clientX : evt.clientX;
                const clientY = isTouch ? evt.touches[0].clientY : evt.clientY;
                const x = (clientX - rect.left) * (canvas.width / rect.width);
                const y = (clientY - rect.top) * (canvas.height / rect.height);
                return { x, y };
            }

            function getNodeAtPos(pos) {
                const level = levels[currentLevelIndex];
                if (!level) return -1;
                const tol = Math.max(HIT_TOLERANCE, NODE_RADIUS * 1.4);
                for (let i = 0; i < level.nodes.length; i++) {
                    const node = level.nodes[i];
                    const dx = pos.x - scale(node.x);
                    const dy = pos.y - scale(node.y);
                    if (Math.sqrt(dx * dx + dy * dy) < tol) return i;
                }
                return -1;
            }

            function isConnectionValid(fromNodeIdx, toNodeIdx) {
                const lineId = `${Math.min(fromNodeIdx, toNodeIdx)}-${Math.max(fromNodeIdx, toNodeIdx)}`;
                if (tracedLines.has(lineId)) return false;
                return availableLines.some(l => l.from === fromNodeIdx && l.to === toNodeIdx);
            }

            function handleInputDown(evt) {
                evt.preventDefault();
                if (isTransitioning || levelCompleted) return;
                const pos = getMousePos(evt);
                const nodeIndex = getNodeAtPos(pos);
                if (nodeIndex !== -1) {
                    playerPath = [nodeIndex];
                    isDragging = true;
                    tracedLines.clear();
                }
            }

            function handleInputMove(evt) {
                if (!isDragging || isTransitioning || levelCompleted) return;
                evt.preventDefault();
                const pos = getMousePos(evt);
                livePathEnd = pos;
                const targetNodeIndex = getNodeAtPos(pos);
                const lastNode = playerPath[playerPath.length - 1];
                if (targetNodeIndex !== -1 && targetNodeIndex !== lastNode) {
                    if (isConnectionValid(lastNode, targetNodeIndex)) {
                        const lineId = `${Math.min(lastNode, targetNodeIndex)}-${Math.max(lastNode, targetNodeIndex)}`;
                        tracedLines.add(lineId);
                        playerPath.push(targetNodeIndex);
                        if (tracedLines.size === levels[currentLevelIndex].lines.length) {
                            levelCompleted = true;
                            handleWin();
                        }
                    }
                }
            }

            function handleInputUp(evt) {
                if (isTransitioning || levelCompleted) return;
                evt.preventDefault();
                if (isDragging && tracedLines.size < levels[currentLevelIndex].lines.length) {
                    handleGameOver();
                }
                isDragging = false;
                livePathEnd = null;
            }

            function handleWin() {
                if (isTransitioning) return;
                isTransitioning = true;
                isDragging = false;
                livePathEnd = null;
                levelIndicator.textContent = "Level Complete!";
                levelIndicator.style.color = '#00ffff';
                totalScore += levels[currentLevelIndex].difficulty;
                saveProgress();
                setTimeout(() => {
                    levelCompleted = false;
                    if (currentLevelIndex + 1 < levels.length) {
                        setupLevel(currentLevelIndex + 1);
                    } else {
                        currentLevelIndex = levels.length;
                        updateUI();
                    }
                }, 1200);
            }

            function handleGameOver() {
                if (isTransitioning) return;
                isTransitioning = true;
                isDragging = false;
                gameOverModal.style.display = 'flex';
            }

            // ✅ BADGE BUTTON - FIXED
            badgeButton.addEventListener('click', function(e) {
                console.log('Badge button clicked!');
                e.stopPropagation();
                badgeModal.style.display = 'flex';
            });

            badgeModal.addEventListener('click', (e) => { 
                if (e.target === badgeModal) {
                    badgeModal.style.display = 'none';
                }
            });

            saveBadgeButton.addEventListener('click', function(e) {
                console.log('Save badge clicked!');
                e.stopPropagation();
                const name = playerNameInput.value || 'Anonymous';
                generateBadge(name);
                badgeModal.style.display = 'none';
            });

            function generateBadge(playerName) {
                const W = 500, H = 300;
                const badgeCanvas = document.createElement('canvas');
                badgeCanvas.width = W; badgeCanvas.height = H;
                const bctx = badgeCanvas.getContext('2d');
                const grad = bctx.createLinearGradient(0, 0, 0, H);
                grad.addColorStop(0, '#1b2735'); grad.addColorStop(1, '#090a0f');
                bctx.fillStyle = grad;
                bctx.fillRect(0, 0, W, H);
                bctx.lineWidth = 4;
                bctx.strokeStyle = '#00ffff';
                bctx.strokeRect(2, 2, W - 4, H - 4);
                const icon = new Image();
                icon.crossOrigin = "Anonymous";
                icon.src = 'https://raw.githubusercontent.com/Mirjan-Ali-Sha/tracepuzzle/main/TracePuzzle-icon.png';
                icon.onload = () => {
                    bctx.drawImage(icon, 25, 90, 100, 100);
                    bctx.font = "bold 36px Orbitron, sans-serif";
                    bctx.textAlign = 'center';
                    bctx.fillStyle = '#00ffff';
                    bctx.shadowColor = '#00ffff';
                    bctx.shadowBlur = 10;
                    bctx.fillText("TracePuzzle", W / 2, 60);
                    bctx.shadowBlur = 5;
                    bctx.font = "22px Orbitron, sans-serif";
                    bctx.textAlign = 'left';
                    bctx.fillStyle = '#ffffff';
                    bctx.fillText(`Player: ${playerName}`, 160, 130);
                    bctx.font = "18px Orbitron, sans-serif";
                    bctx.fillStyle = '#ff00ff';
                    const levelsCompleted = Math.min(currentLevelIndex, levels.length);
                    bctx.fillText(`Score: ${totalScore}`, 160, 165);
                    bctx.fillText(`Levels Completed: ${levelsCompleted}`, 160, 195);
                    bctx.font = "14px Orbitron, sans-serif";
                    bctx.fillStyle = 'rgba(255,255,255,0.8)';
                    bctx.fillText(`Game by: Mirjan Ali Sha`, 160, 230);
                    const link = document.createElement('a');
                    link.download = `TracePuzzle-Badge-${playerName}.png`;
                    link.href = badgeCanvas.toDataURL('image/png');
                    link.click();
                };
                icon.onerror = () => alert("Could not load badge icon.");
            }

            playAgainButton.addEventListener('click', function(e) {
                console.log('Play again clicked!');
                e.stopPropagation();
                gameOverModal.style.display = 'none';
                isTransitioning = false;
                setupLevel(currentLevelIndex);
            });
            
            getBadgeFromGameOverButton.addEventListener('click', function(e) {
                console.log('Get badge from game over clicked!');
                e.stopPropagation();
                gameOverModal.style.display = 'none';
                badgeModal.style.display = 'flex';
                isTransitioning = false;
            });

            // ✅ RESET BUTTON - FIXED
            resetButton.addEventListener('click', function(e) {
                console.log('Reset button clicked!');
                e.stopPropagation();
                if (confirm('This will delete ALL saved progress and restart the game. Continue?')) {
                    try {
                        localStorage.clear();
                        sessionStorage.clear();
                        document.cookie.split(";").forEach(cookie => {
                            document.cookie = cookie.replace(/^ +/, "").replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`);
                        });
                        if ('serviceWorker' in navigator) {
                            navigator.serviceWorker.getRegistrations().then(registrations => {
                                registrations.forEach(registration => registration.unregister());
                            });
                        }
                        if ('caches' in window) {
                            caches.keys().then(names => {
                                names.forEach(name => caches.delete(name));
                            });
                        }
                    } catch(e) {
                        console.error('Storage clear error:', e);
                    }
                    setTimeout(() => {
                        window.location.href = window.location.origin + window.location.pathname + '?nocache=' + Date.now();
                    }, 100);
                }
            });

            startOverButton.addEventListener('click', function(e) {
                console.log('Start over clicked!');
                e.stopPropagation();
                currentLevelIndex = 0; 
                totalScore = 0; 
                saveProgress(); 
                setupLevel(0); 
            });

            let lastTime = 0, pulse = 0;
            function animate(ts) {
                const delta = ts - lastTime || 0; lastTime = ts;
                pulse += delta * 0.002;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (currentLevelIndex < levels.length) {
                    drawGuideLines();
                    drawPlayerTrace();
                    drawNodes(pulse);
                } else {
                    ctx.font = `bold ${Math.max(16, scaleFactor * 8)}px Orbitron, sans-serif`;
                    ctx.fillStyle = '#00ffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 10;
                    ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
                    ctx.shadowBlur = 0;
                }
                requestAnimationFrame(animate);
            }

            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('mousedown', handleInputDown);
            window.addEventListener('mousemove', handleInputMove);
            window.addEventListener('mouseup', handleInputUp);
            canvas.addEventListener('touchstart', handleInputDown, {passive:false});
            window.addEventListener('touchmove', handleInputMove, {passive:false});
            window.addEventListener('touchend', handleInputUp);

            window.addEventListener('load', () => {
                setTimeout(() => splashScreen.classList.add('hidden'), 1800);
            });

            loadProgress();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupLevel(currentLevelIndex);
            requestAnimationFrame(animate);

            console.log('Game initialized successfully!');

        } catch(error) {
            console.error('Critical error:', error);
            alert('Game initialization error: ' + error.message);
        }
    </script>
</body>
</html>
